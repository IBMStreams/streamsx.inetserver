<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en-us" lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2005"/>
<meta name="DC.rights.owner" content="(C) Copyright 2005"/>
<meta name="DC.Type" content="reference"/>
<meta name="DC.Title" content="SPL File DynaJson.spl"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="spldoc_compilationunit"/>
<link rel="stylesheet" type="text/css" href="../../html/commonltr.css"/>
<link rel="stylesheet" type="text/css" href="../../html/spldoc.css"/>
<title>SPL File DynaJson.spl</title>
</head>
<body id="spldoc_compilationunit">


<h1 class="title topictitle1">SPL File <tt class="ph tt">DynaJson.spl</tt></h1>

<div class="body refbody">
<div class="section">
<p class="p">
<a class="xref" href="../toolkits/toolkits.html">Toolkits</a> &gt; <a class="xref" href="tk$RequestProcessJson.html">RequestProcessJson 1.0.0</a> &gt; <a class="xref" href="ns$application.html">application</a> &gt; DynaJson.spl</p>

</div>

<div class="section"><h2 class="title sectiontitle splhead-1">Content</h2>
  
  <dl class="dl">
    <dt class="dt dlterm"/>
<dd class="dd"/>

    
      <dt class="dt dlterm splhead-2">Operators</dt>

      <dd class="dd">
<ul class="sl simple">
<li class="sli"><strong class="ph b"><a class="xref" href="spl$application$DynaJson.html#spldoc_compilationunit__composite_operator__DynJson">DynJson</a></strong>: This has the same functioinality as DysonTuple application, excpet this one gets  processes the request/response as json.
</li>

</ul>

      </dd>

    
  </dl>

</div>

<div class="section"><h2 class="title sectiontitle splhead-1">Composites</h2>
  
</div>

<div class="section" id="spldoc_compilationunit__composite_operator__DynJson"><h2 class="title sectiontitle splpart">composite DynJson</h2>
  
</div>

<div class="section splgraph">
  <embed class="image" src="../../image/tk$RequestProcessJson/op$application$DynJson.svg" width="640" height="141"/>
</div>

<div class="section">

<p class="p">This has the same functioinality as DysonTuple application, excpet this one gets  processes the request/response as json. Refer to the DysonTuple for and description. 
</p>

<p class="p">This code is needs to parse the JSON object since json JSONToTuple does not handle  handle maps(objects). This example is tenitive at best since it has not error processing,  using this operator with Python and the topology tookit is the way to go. 
</p>

</div>

<div class="section">
</div>

<div class="section">
</div>

<div class="section">
</div>

<div class="section"><h2 class="title sectiontitle splhead-2">SPL Source Code</h2>
  
</div>


<div class="section">
   <pre class="pre codeblock">

 public composite DynJson
 {
 	type
 		ReqProc = HTTPRequest reqRsp, rstring templateFile, map&lt;rstring,
 			rstring&gt; context ;
 		ReqRsp = tuple&lt;HTTPRequest ex&gt; ;
 	graph
 		(stream&lt;rstring string&gt; TupleToJSON_12_out0) as TupleToJSON_12 =
 			TupleToJSON(httpResponse)
 		{
 		}
 
 		(stream&lt;rstring jsonString&gt; httpRequest) as HttpTuple =
 			HTTPRequestProcess(TupleToJSON_12_out0 as inPort0Alias)
 		{
 			param
 				context : "livepage" ;
 				contextResourceBase : getThisToolkitDir() + "/opt/html" ;  
 				responseJsonAttributeName : "string" ;
 				port : 8080 ;
 		}
 
 		(stream&lt;HTTPRequest&gt; Custom_10_out0 as O) as JsonShred = Custom(httpRequest
 			as I)
 		{
 			logic
 				state :
 				{
 					mutable HTTPRequest tupleOut ;
 					mutable list&lt;rstring&gt; body ;
 					mutable list&lt;rstring&gt; header ;
 					mutable rstring headStr ;
 					mutable rstring bodyStr ;
 					mutable list&lt;rstring&gt; entry ;
 					mutable list&lt;rstring&gt; ele ;
 					mutable int32 idxStart, idxEnd ;
 					mutable rstring bodyChop ;
 					mutable rstring tstStr ;
 					mutable map&lt;rstring, rstring&gt; headMap = { } ;
 					mutable int64 keyVal ;
 					mutable rstring keyStr ;
 					rstring keyTxt = '"key":' ;
 				}
 
 				onTuple I :
 				{
 					tokenize(I.jsonString, '"header":{', false, false, body) ;
 					tokenize(body [ 1 ], '},', false, false, header) ;
 					bodyStr = body [ 0 ] + header [ 1 ] ;
 					// drop the 1st last character
 					bodyStr = substring(bodyStr, 1, length(bodyStr) - 2) ;
 					headStr = "" ;
 					for(rstring tmp in header [ : 1 ]) headStr += tmp ;
 					// drop the 1st &amp; last character
 					headStr = substring(headStr, 1, length(headStr) - 2) ;
 
 					// find the key (a numeric value) and extract the value.
 					idxStart = findFirst(bodyStr, keyTxt) ;
 					idxEnd = findFirst(bodyStr, ',', idxStart) ;
 					keyStr = substring(bodyStr, idxStart, idxEnd - idxStart) ;
 					keyVal =(int64) keyStr [ length(keyTxt) : ] ;
 					tupleOut.key = keyVal ;
 					// drop the key entry from string. 
 					bodyChop = bodyStr [ : idxStart ] + bodyStr [ idxEnd : ] ;
 					bodyChop = substring(bodyChop, 1, length(bodyChop) - 2) ;
 					tokenize(bodyChop, '","', false, false, body) ;
 					for(rstring data in body)
 					{
 						tokenize(data, '":"', false, true, ele) ;
 						if (size(ele) &gt; 1) {
 							if("request" == ele [ 0 ]) tupleOut.request = ele [ 1 ] ;
 							if("contentType" == ele [ 0 ]) tupleOut.contentType = ele [ 1 ] ;
 							if("method" == ele [ 0 ]) tupleOut.method = ele [ 1 ] ;
 							if("pathInfo" == ele [ 0 ]) tupleOut.pathInfo = ele [ 1 ][1:] ;
 							if("statusMessage" == ele [ 0 ]) tupleOut.statusMessage = ele [ 1 ] ;
 						}
 					}
 
 					clearM(headMap) ;
 					tokenize(headStr, '","', false, false, header) ;
 					// get header;
 					for(rstring data in header)
 					{
 						tokenize(data, '":"', false, false, ele) ;
 						insertM(headMap, ele [ 0 ], ele [ 1 ]) ;
 					}
 
 					tupleOut.header = headMap ;
 					println("exit:pathInfo -- &gt;" + tupleOut.pathInfo + "&lt;");
 					submit(tupleOut, O) ;
 
 				}
 
 			}
 
 		(stream&lt;ReqProc&gt; normalizedRequest as O) as Normalize =
 				Custom(Functor_10_out0 as I)
 			{
 				logic
 					state :
 					{
 						mutable ReqProc rProc ;
 						mutable map&lt;rstring, rstring&gt; context ;
 						map&lt;rstring, rstring&gt; contextError = { "ERROR-requestInput" :
 							"had no entry parsed" } ;
 						mutable list&lt;rstring&gt; dict ;
 						mutable list&lt;rstring&gt; keyval ;
 					}
 
 					onTuple I :
 					{
 						dict = tokenize(I.request, "&amp;", true) ;
 						clearM(context) ;
 						if(size(dict) &gt; 0)
 						{
 							for(rstring entry in dict)
 							{
 								keyval = tokenize(entry, "=", true) ;
 								if(size(keyval) &gt; 1) context = insert(context, keyval [ 0 ], keyval [ 1
 									]) ;
 								else if(size(keyval) == 1) context = insert(context, keyval [ 0 ],
 									"") ;
 								else context = insert(context, "ERROR-nameValueParse", "FAILUE") ;
 							}
 
 						}
 
 						else
 						{
 							keyval = tokenize(I.request, "=", true) ;
 							if(size(keyval) &gt; 1) context = insert(context, keyval [ 0 ], keyval [ 1
 								]) ;
 							else if(size(keyval) == 1) context = insert(context, keyval [ 0 ], "") ;
 							else context = insert(context, "ERROR-nameValueParse",
 								"FAILURE single entry") ;
 						}
 
 						assignFrom(rProc.reqRsp, I) ;
 						rProc.context = context ;
 						submit(rProc, O) ;
 					}
 
 				}
 
 			(stream&lt;normalizedRequest&gt; processed as O) as ProcessingPhase =
 					Custom(normalizedRequest as I)
 				{
 					logic
 						state :
 						{
 							mutable rstring normalFile = "/livepage/normal.hbs" ;
 							mutable rstring junkFile = "/livepage/junk.hbs" ;
 							mutable rstring name ;
 							map&lt;rstring, rstring&gt; newShort = { "occupation" : "developer software",
 								"profession" : "create software" } ;
 							map&lt;rstring, rstring&gt; newLong = { "occupation" : "developer land",
 								"profession" : "build buildings" } ;
 							mutable map&lt;rstring, rstring&gt; newContext ;
 						}
 
 						onTuple I :
 						{
 							I.templateFile =(length(I.context [ 'password' ]) &gt; 0) ? normalFile :
 								junkFile ;
 							name = I.context [ 'name' ] ;
 							I.context =(length(name) &gt; 4) ? newLong : newShort ;
 							I.context = insert(I.context, "name", name) ;
 							submit(I, O) ;
 						}
 
 				}
 
 				/*
 		 * This is very hack but it's cool - This builds the HTML that is to returned to the browser. 
 		 * The page will invokes the template passed in the I.templateFile attribute, the variables
 		 * that the template file will be using variables that are in the I.context (map&lt;rstring, rstring&gt;).
 		 * When the html page gets loaded it invokes the &lt;script&gt; that gets the template file then invokes
 		 * the template file with the variables, javascript + jquery cool like dynamite and dangerous - like 
 		 * nitro-glycerince. 
 		 */
 			(stream&lt;HTTPRequest&gt; htmlFormatted as O) as BuildHtml = Custom(processed as
 					I)
 				{
 					logic
 						state :
 						{
 							mutable HTTPRequest rRsp ;
 							mutable rstring bstr ;
 							rstring preHtml =
 								'&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt;&lt;title&gt;Demonstration&lt;/title&gt;&lt;head&gt;&lt;script&gt;' ;
 							mutable rstring buildResponse ;
 							mutable rstring dataForTemplate_File = // example of how it should look. 
 							'var templateFile = "/livepage/junk.hbs";' ;
 							mutable rstring dataForTemplate_Context = // example of how it should look.
 							'var context = { "name" : "Joe Shome", "occupation" : "developer" , "profession" : "hack"};' ;
 							rstring postHtml = '&lt;/script&gt;&lt;meta charset="UTF-8"&gt;
 &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"&gt;
 &lt;/script&gt;&lt;script src="/livepage/libs/handlebars.min-latest.js"&gt;
 &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;
 $.get(templateFile).done(function(template) {
 var templateScript = Handlebars.compile(template);
 var html = templateScript(context);
 $(document.body).append(html);});
 &lt;/script&gt;&lt;/body&gt;' ;
 						}
 
 						onTuple I :
 						{
 							assignFrom(rRsp, I.reqRsp) ;
 							dataForTemplate_File = 'var templateFile = "' + I.templateFile + '";' ;
 							bstr = 'var context = {' ;
 							for(rstring key in keys(I.context))
 							{
 								bstr += '"' + key + '":"' + I.context [ key ] + '",' ;
 							}
 
 							dataForTemplate_Context = bstr + '};' ;
 							buildResponse = preHtml + dataForTemplate_File + dataForTemplate_Context
 								+ postHtml ;
 							rRsp.response = buildResponse ;
 							submit(rRsp, O) ;
 						}
 
 				}
 
 			() as DebugView = FileSink(httpResponse as Functor_7_out0)
 				{
 					param
 						file : "/dev/stdout" ;
 						flush : 1u ;
 				}
 
 			(stream&lt;HTTPRequest&gt; httpResponse as O) as PrepHttp = Custom(htmlFormatted
 					as I)
 				{
 					logic
 						onTuple I :
 						{
 						// TODO * default? done by operator?
 							I.header [ "Content-Type" ] = "text/html" ;
 							// TODO * this should be done in the operator
 							I.header [ "Content-Length" ] =(rstring) length(I.response) ;
 							submit(I, O) ;
 						}
 
 				}
 
 
 			(stream&lt;Custom_10_out0&gt; Functor_10_out0 as O) as FilterRequest =
 					Functor(Custom_10_out0 as I)
 				{
 					param
 						filter : I.pathInfo == "/login" ;
 					output
 						O : response = upper(I.request);
 				}
 
 		}

   </pre>

</div>

</div>


</body>
</html>