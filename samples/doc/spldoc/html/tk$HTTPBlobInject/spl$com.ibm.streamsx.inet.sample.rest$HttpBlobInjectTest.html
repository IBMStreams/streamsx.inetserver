<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en-us" lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2005"/>
<meta name="DC.rights.owner" content="(C) Copyright 2005"/>
<meta name="DC.Type" content="reference"/>
<meta name="DC.Title" content="SPL File HttpBlobInjectTest.spl"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="spldoc_compilationunit"/>
<link rel="stylesheet" type="text/css" href="../../html/commonltr.css"/>
<link rel="stylesheet" type="text/css" href="../../html/spldoc.css"/>
<title>SPL File HttpBlobInjectTest.spl</title>
</head>
<body id="spldoc_compilationunit">


<h1 class="title topictitle1">SPL File <tt class="ph tt">HttpBlobInjectTest.spl</tt></h1>

<div class="body refbody">
<div class="section">
<p class="p">
<a class="xref" href="../toolkits/toolkits.html">IBMStreams streamsx.inetserver Toolkit</a> &gt; <a class="xref" href="tk$HTTPBlobInject.html">HTTPBlobInject 1.0.0</a> &gt; <a class="xref" href="ns$com.ibm.streamsx.inet.sample.rest.html">com.ibm.streamsx.inet.sample.rest</a> &gt; HttpBlobInjectTest.spl</p>

</div>

<div class="section"><h2 class="title sectiontitle splhead-1">Content</h2>
  
  <dl class="dl">
    <dt class="dt dlterm"/>
<dd class="dd"/>

    
      <dt class="dt dlterm splhead-2">Operators</dt>

      <dd class="dd">
<ul class="sl simple">
<li class="sli"><strong class="ph b"><a class="xref" href="spl$com.ibm.streamsx.inet.sample.rest$HttpBlobInjectTest.html#spldoc_compilationunit__composite_operator__HttpBlobInjectTest">HttpBlobInjectTest</a></strong>: To test the HTTPBLOBInjection operator, you can do the following.
</li>

</ul>

      </dd>

    
  </dl>

</div>

<div class="section"><h2 class="title sectiontitle splhead-1">Composites</h2>
  
</div>

<div class="section" id="spldoc_compilationunit__composite_operator__HttpBlobInjectTest"><h2 class="title sectiontitle splpart">composite HttpBlobInjectTest</h2>
  
</div>

<div class="section splgraph">
  <embed class="image" src="../../image/tk$HTTPBlobInject/op$com.ibm.streamsx.inet.sample.rest$HttpBlobInjectTest.svg" width="232" height="109"/>
</div>

<div class="section">

<div class="p">To test the HTTPBLOBInjection operator, you can do the following.
<ol class="ol">
<li class="li"> Compile this SPL application and run it.</li>

<li class="li"> In this sample project directory, there is a python script: http_bin_test_client.py    Run that script which will send the blob content from the two tar.gz files already present in the data directory.     python3 http_bin_test_client.py</li>

<li class="li"> Ensure the blob contents are received by checking for the result messages printed either on the screen or in the PE stdouterr log file.</li>

<li class="li"> You can now diff the files sent from the data directory and the received and saved files.</li>

<li class="li"> In the end, you may want to delete the received and saved files in the /tmp directory. </li>

</ol>

</div>

</div>

<div class="section">
</div>

<div class="section">
</div>

<div class="section">
</div>

<div class="section"><h2 class="title sectiontitle splhead-2">SPL Source Code</h2>
  
</div>


<div class="section">
   <pre class="pre codeblock">

 public composite HttpBlobInjectTest {
 	graph
 		// This operator can receive any binary data sent from
 		// one or more HTTP clients (.wav, .jpg, .mov, .tar etc.)
 		// First attribute in the output stream must be of type blob.
 		// Second attribute in the output stream is optional. If present, it must be
 		// a map&lt;rstring, rstring&gt; where the HTTP request headers and their values will be stored.
 		stream&lt;blob x, map&lt;rstring, rstring&gt; httpRequestHeaders&gt; BinData = HTTPBLOBInjection() {
 			param
 				port: 8080;
 		}
 		
 		() as MySink1 = Custom(BinData as BD) {
 			logic
 				state: {
 					mutable int32 _tupleCnt = 0;
 					list&lt;rstring&gt; _files = ["dummy", "result1", "result2"];
 				}
 				
 				onTuple BD: {
 					printStringLn("HTTP binary Content Length for tuple " +
 						(rstring)++_tupleCnt + "=" + (rstring)size(BD.x));
 					printStringLn("HTTP Request Headers=" + (rstring)BD.httpRequestHeaders);
 
 					if (_tupleCnt &lt;= 2) {
 						// Write the received binary content to a file to
 						// verify the received blob is same as the
 						// original content sent by the HTTP client.
 						mutable int32 fileError = 0;
 						mutable uint64 fileHandle = 0ul;
 						rstring fileName = "/tmp/" + _files[_tupleCnt];
 						printStringLn("Saving to file : " + fileName);
 						fileHandle = fopen(fileName, "w+", fileError);
 						
 						if (fileError != 0) {
 							printStringLn ("Error while creating the file " + fileName + 
 								". (Error: " + (rstring) fileError + ") Giving up.\n");
 							abort();
 						}
 						
 						list&lt;uint8&gt; binaryContent = (list&lt;uint8&gt;)BD.x;
 						fwrite(binaryContent, fileHandle, 0ul, (uint64)size(binaryContent), fileError);
 						fclose(fileHandle, fileError);
 
 						if (_tupleCnt == 2) {
 							printStringLn("You can do a diff of the two files sent from data directory with the ones we received and saved as shown above. You may want to delete those two saved files after doing the diff.");
 						}
 					} else {
 						printStringLn("Else");
 					}
 
 				}
 		}
 		
 	config
 		restartable: false;
 }

   </pre>

</div>

</div>


</body>
</html>