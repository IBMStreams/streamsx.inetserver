<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en-us" lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2005"/>
<meta name="DC.rights.owner" content="(C) Copyright 2005"/>
<meta name="DC.Type" content="reference"/>
<meta name="DC.Title" content="SPL File DynaTuple.spl"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="spldoc_compilationunit"/>
<link rel="stylesheet" type="text/css" href="../../html/commonltr.css"/>
<link rel="stylesheet" type="text/css" href="../../html/spldoc.css"/>
<title>SPL File DynaTuple.spl</title>
</head>
<body id="spldoc_compilationunit">


<h1 class="title topictitle1">SPL File <tt class="ph tt">DynaTuple.spl</tt></h1>

<div class="body refbody">
<div class="section">
<p class="p">
<a class="xref" href="../toolkits/toolkits.html">Toolkits</a> &gt; <a class="xref" href="tk$RequestProcessTuple.html">RequestProcessTuple 1.0.0</a> &gt; <a class="xref" href="ns$application.html">application</a> &gt; DynaTuple.spl</p>

</div>

<div class="section"><h2 class="title sectiontitle splhead-1">Content</h2>
  
  <dl class="dl">
    <dt class="dt dlterm"/>
<dd class="dd"/>

    
      <dt class="dt dlterm splhead-2">Operators</dt>

      <dd class="dd">
<ul class="sl simple">
<li class="sli"><strong class="ph b"><a class="xref" href="spl$application$DynaTuple.html#spldoc_compilationunit__composite_operator__DynTuple">DynTuple</a></strong>: This is an example of using the HTTPRequestProcess() operator to put up a form,  get form input and generate a response.
</li>

</ul>

      </dd>

    
  </dl>

</div>

<div class="section"><h2 class="title sectiontitle splhead-1">Composites</h2>
  
</div>

<div class="section" id="spldoc_compilationunit__composite_operator__DynTuple"><h2 class="title sectiontitle splpart">composite DynTuple</h2>
  
</div>

<div class="section splgraph">
  <embed class="image" src="../../image/tk$RequestProcessTuple/op$application$DynTuple.svg" width="640" height="175"/>
</div>

<div class="section">

<p class="p">This is an example of using the HTTPRequestProcess() operator to put up a form,  get form input and generate a response. This uses the Tuple aspect of the operator, the RequestProcessJson example does this same process with the Json aspect. 
</p>

<div class="p">Description: 
<ul class="ul">
<li class="li"> Using th context put up the index.html page in /opt/html, which includes a form.</li>

<li class="li"> The forms action (/livepage/HttpTuple/ports/analyze/0/login) post to the operator.</li>

<li class="li"> The HTTPTupleProcess operator outputs the request, note the use of pathInfo to route the request.</li>

<li class="li"> On completion of the processing, the response is input to the originaling HTTPTupleProcess operator. </li>

</ul>

</div>

<div class="p">The goal:
<ul class="ul">
<li class="li"> Demonstrate the processing of forms.</li>

<li class="li"> Reinterate how important it is NOT to mess with the id.  </li>

</ul>

</div>

</div>

<div class="section">
</div>

<div class="section">
</div>

<div class="section">
</div>

<div class="section"><h2 class="title sectiontitle splhead-2">SPL Source Code</h2>
  
</div>


<div class="section">
   <pre class="pre codeblock">

 public composite DynTuple
 {
 	type		
 		ReqProc = HTTPRequest reqRsp, rstring templateFile, map&lt;rstring,
 			rstring&gt; context ;
 	graph
 		(stream&lt;HTTPRequest&gt; httpRequest) as HttpTuple = HTTPRequestProcess(httpResponse)
 		{
 			param
 				context : "livepage" ;
 				contextResourceBase : getThisToolkitDir() + "/opt/html" ;
 				port : 8080 ;
 		}
 
 		(stream&lt;HTTPRequest&gt; functorLogin as O) as LoginFilter = Functor(httpRequest as I)
 		{ // /login request ? drop on floor if not. Real code with have multiple branches. 
 
 			param
 				filter : I.pathInfo == "/login" ;
 			output
 				O : response = upper(I.request) ;
 		}
 
 		(stream&lt;ReqProc&gt; normalizedRequest as O) as Normalize = Custom(functorLogin
 			as I)
 		{
 			logic
 				state :
 				{
 					mutable ReqProc rProc ;
 					mutable map&lt;rstring, rstring&gt; context ;
 					map&lt;rstring, rstring&gt; contextError = { "ERROR-requestInput" :
 						"had no entry parsed" } ;
 					mutable list&lt;rstring&gt; dict ;
 					mutable list&lt;rstring&gt; keyval ;
 				}
 
 				onTuple I :
 				{
 					dict = tokenize(I.request, "&amp;", true) ;
 					clearM(context) ;
 					if(size(dict) &gt; 0)
 					{
 						for(rstring entry in dict)
 						{
 						println("entry:" + entry);
 							keyval = tokenize(entry, "=", true) ;
 							if(size(keyval) &gt; 1) context = insert(context, keyval [ 0 ], keyval [ 1
 								]) ;
 							else if(size(keyval) == 1) context = insert(context, keyval [ 0 ], "") ;
 							else context = insert(context, "ERROR-nameValueParse", "FAILUE") ;
 						}
 
 					}
 
 					else
 					{
 						keyval = tokenize(I.request, "=", true) ;
 						if(size(keyval) &gt; 1) context = insert(context, keyval [ 0 ], keyval [ 1
 							]) ;
 						else if(size(keyval) == 1) context = insert(context, keyval [ 0 ], "") ;
 						else context = insert(context, "ERROR-nameValueParse",
 							"FAILURE single entry") ;
 					}
 
 					assignFrom(rProc.reqRsp, I) ;
 					rProc.context = context ;
 					submit(rProc, O) ;
 				}
 
 			}
 
 		(stream&lt;normalizedRequest&gt; processed as O) as ProcessingPhase =
 				Custom(normalizedRequest as I)
 			{
 				logic
 					state :
 					{
 						mutable rstring normalFile = "/normal.hbs" ;
 						mutable rstring junkFile = "/junk.hbs" ;
 						mutable rstring name ;
 						map&lt;rstring, rstring&gt; newShort = { "occupation" : "developer software",
 							"profession" : "create software" } ;
 						map&lt;rstring, rstring&gt; newLong = { "occupation" : "developer land",
 							"profession" : "build buildings" } ;
 						mutable map&lt;rstring, rstring&gt; newContext ;
 					}
 
 					onTuple I :
 					{
 						I.templateFile =(length(I.context [ 'password' ]) &gt; 0) ? normalFile :
 							junkFile ;
 						name = I.context [ 'name' ] ;
 						I.context =(length(name) &gt; 4) ? newLong : newShort ;
 						I.context = insert(I.context, "name", name) ;
 						submit(I, O) ;
 					}
 
 			}
 
 			/*
 		 * This is very hack but it's cool - This builds the HTML that is to returned to the browser. 
 		 * The page will invokes the template passed in the I.templateFile attribute, the variables
 		 * that the template file will be using variables that are in the I.context (map&lt;rstring, rstring&gt;).
 		 * When the html page gets loaded it invokes the &lt;script&gt; that gets the template file then invokes
 		 * the template file with the variables, javascript + jquery cool like dynamite and dangerous - like 
 		 * nitro-glycerince. 
 		 */
 		(stream&lt;HTTPRequest&gt; htmlFormatted as O) as BuildHtml = Custom(processed as I)
 			{
 				logic
 					state :
 					{
 						mutable HTTPRequest rRsp ;
 						mutable rstring bstr ;
 						rstring preHtml =
 							'&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt;&lt;title&gt;Demonstration&lt;/title&gt;&lt;head&gt;&lt;script&gt;' ;
 						mutable rstring buildResponse ;
 						mutable rstring dataForTemplate_File = // example of how it should look. 
 						'var templateFile = "/junk.hbs";' ;
 						mutable rstring dataForTemplate_Context = // example of how it should look.
 						'var context = { "name" : "Joe Shome", "occupation" : "developer" , "profession" : "hack"};' ;
 						rstring postHtml = '&lt;/script&gt;&lt;meta charset="UTF-8"&gt;
 &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"&gt;
 &lt;/script&gt;&lt;script src="/libs/handlebars.min-latest.js"&gt;
 &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;
 $.get(templateFile).done(function(template) {
 var templateScript = Handlebars.compile(template);
 var html = templateScript(context);
 $(document.body).append(html);});
 &lt;/script&gt;&lt;/body&gt;' ;
 					}
 
 					onTuple I :
 					{
 						assignFrom(rRsp, I.reqRsp) ;
 						dataForTemplate_File = 'var templateFile = "' + I.templateFile + '";' ;
 						bstr = 'var context = {' ;
 						for(rstring key in keys(I.context))
 						{
 							bstr += '"' + key + '":"' + I.context [ key ] + '",' ;
 						}
 
 						dataForTemplate_Context = bstr + '};' ;
 						buildResponse = preHtml + dataForTemplate_File + dataForTemplate_Context
 							+ postHtml ;
 						rRsp.response = buildResponse ;
 						submit(rRsp, O) ;
 					}
 
 			}
 
 		() as DebugView = FileSink(httpRequest as Functor_7_out0)
 			{
 				param
 					file : "/dev/stdout" ;
 					flush : 1u ;
 			}
 
 		(stream&lt;HTTPRequest&gt; httpResponse as O) as PrepHttp = Custom(htmlFormatted as I)
 			{
 				logic
 					onTuple I :
 					{
 					// TODO * default? done by operator?
 						I.header [ "Content-Type" ] = "text/html" ;
 						// TODO * this should be done in the operator
 						I.header [ "Content-Length" ] =(rstring) length(I.response) ;
 						submit(I, O) ;
 					}
 
 			}
 
 	}

   </pre>

</div>

</div>


</body>
</html>